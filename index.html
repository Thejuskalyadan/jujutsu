<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>JJK: Cursed Technique</title>

<style>
body {
    margin: 0;
    overflow: hidden;
    background-color: #000;
    font-family: "Courier New", sans-serif;
}

#ui {
    position: absolute;
    top: 10%;
    width: 100%;
    text-align: center;
    color: #fff;
    pointer-events: none;
    z-index: 10;
}

h1 {
    font-size: 3rem;
    margin: 0;
    letter-spacing: 10px;
    font-weight: 900;
    background: linear-gradient(to bottom, #fff, #888);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

#technique-name {
    font-size: 1.2rem;
    color: #00ffff;
    margin-top: 15px;
    font-weight: bold;
    letter-spacing: 4px;
    text-transform: uppercase;
}

/* Floating Camera */
#video-container {
    position: fixed;
    bottom: 20px;
    left: 20px;

    width: 260px;
    aspect-ratio: 4 / 3;

    background: rgba(0,0,0,0.4);
    backdrop-filter: blur(10px);

    border-radius: 18px;
    border: 1px solid rgba(255,255,255,0.15);

    overflow: hidden;
    z-index: 50;

    transform: scaleX(-1);

    cursor: grab;
    user-select: none;

    animation: floaty 4s ease-in-out infinite;

    box-shadow: 0 0 25px rgba(0,0,0,0.8);
}

@keyframes floaty {
    0% { transform: scaleX(-1) translateY(0px); }
    50% { transform: scaleX(-1) translateY(-6px); }
    100% { transform: scaleX(-1) translateY(0px); }
}

video {
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0.8;
}

#output_canvas {
    position: absolute;
    pointer-events: none;
    inset: 0;
}

/* Grain */
#grain {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 5;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.08'/%3E%3C/svg%3E");
}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>

<body>

<div id="grain"></div>

<div id="ui">
    <h1>jujutsu</h1>
    <div id="technique-name">CURSED ENERGY</div>
</div>

<div id="video-container">
    <video class="input_video"></video>
    <canvas id="output_canvas"></canvas>
</div>

<script type="module">
import * as THREE from "three";
import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

/* Scene */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.z = 55;

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* Bloom */
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(innerWidth, innerHeight),
    1.5,
    0.4,
    0.85
);

composer.addPass(bloomPass);

/* Particles */
const COUNT = 20000;

const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT * 3);
const colors = new Float32Array(COUNT * 3);
const sizes = new Float32Array(COUNT);

const targetPositions = new Float32Array(COUNT * 3);
const targetColors = new Float32Array(COUNT * 3);
const targetSizes = new Float32Array(COUNT);

geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
geometry.setAttribute("size", new THREE.BufferAttribute(sizes, 1));

const particles = new THREE.Points(
    geometry,
    new THREE.PointsMaterial({
        size: 0.3,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthWrite: false,
    })
);

scene.add(particles);

/* Energy Core */
// const core = new THREE.Mesh(
//     new THREE.SphereGeometry(2.2, 32, 32),
//     new THREE.MeshBasicMaterial({
//         color: 0xbb00ff,
//         transparent: true,
//         opacity: 0.9,
//     })
// );

// scene.add(core);

/* State */
let currentTech = "neutral";
let shakeIntensity = 0;
let activationPulse = 1;
let targetBloom = 1.2;

/* Cooldown */
let lastSwitchTime = 0;
const SWITCH_COOLDOWN = 120; // ms





/* ================= TECHNIQUE GENERATORS ================= */

function getRed(i) {
    if (i < COUNT * 0.1) {
        const r = Math.random() * 9;
        const theta = Math.random() * 6.28;
        const phi = Math.acos(2 * Math.random() - 1);

        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi),
            r: 3,
            g: 0.1,
            b: 0.1,
            s: 2.5,
        };
    } else {
        const armCount = 3;
        const t = i / COUNT;
        const angle = t * 15 + (i % armCount) * ((Math.PI * 2) / armCount);
        const radius = 2 + t * 40;

        return {
            x: radius * Math.cos(angle),
            y: radius * Math.sin(angle),
            z: (Math.random() - 0.5) * (10 * t),
            r: 0.8,
            g: 0,
            b: 0,
            s: 1.0,
        };
    }
}

function getVoid(i) {
    if (i < COUNT * 0.15) {
        const angle = Math.random() * Math.PI * 2;

        return {
            x: 26 * Math.cos(angle),
            y: 26 * Math.sin(angle),
            z: (Math.random() - 0.5),
            r: 1,
            g: 1,
            b: 1,
            s: 2.5,
        };
    } else {
        const radius = 30 + Math.random() * 90;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        return {
            x: radius * Math.sin(phi) * Math.cos(theta),
            y: radius * Math.sin(phi) * Math.sin(theta),
            z: radius * Math.cos(phi),
            r: 0.1,
            g: 0.6,
            b: 1.0,
            s: 0.7,
        };
    }
}

function getPurple(i) {
    if (Math.random() > 0.8)
        return {
            x: (Math.random() - 0.5) * 100,
            y: (Math.random() - 0.5) * 100,
            z: (Math.random() - 0.5) * 100,
            r: 0.5,
            g: 0.5,
            b: 0.7,
            s: 0.8,
        };

    const r = 20;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);

    return {
        x: r * Math.sin(phi) * Math.cos(theta),
        y: r * Math.sin(phi) * Math.sin(theta),
        z: r * Math.cos(phi),
        r: 0.6,
        g: 0.5,
        b: 1.0,
        s: 2.5,
    };
}

function getShrine(i) {
    return {
        x: (Math.random() - 0.5) * 50,
        y: (Math.random() - 0.5) * 20,
        z: (Math.random() - 0.5) * 50,
        r: 0.6,
        g: 0,
        b: 0,
        s: 0.6,
    };
}

/* ðŸŒª Tornado Generator */
function getTornado(i) {

    const height = (Math.random() - 0.5) * 70;
    const radius = 4 + Math.abs(height) * 0.35 + Math.random() * 6;
    const angle = Math.random() * Math.PI * 2;

    return {
        x: radius * Math.cos(angle),
        y: height,
        z: radius * Math.sin(angle),

        r: 0.2 + Math.random() * 0.1,
        g: 1.0,
        b: 0.7 + Math.random() * 0.2,

        s: 1.0 + Math.random() * 0.6
    };
}




/* Camera */

const videoElement = document.querySelector(".input_video");
const canvasElement = document.getElementById("output_canvas");
const canvasCtx = canvasElement.getContext('2d');
canvasElement.width = 640;
canvasElement.height = 480;
let glowColor = '#00ffff';
const hands = new Hands({
    locateFile: (file) =>
        `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
    maxNumHands: 2,modelComplexity: 1,minDetectionConfidence: 0.5,  minTrackingConfidence: 0.5});
let lastDetected = "neutral";
let stableDetected = "neutral";
let stabilityFrames = 0;

const REQUIRED_STABILITY = 6; // tweakable (5â€“10 ideal)

hands.onResults((results) => { 
  console.log(results.multiHandLandmarks);


    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

    let detected = "neutral";

    if (results.multiHandLandmarks) {
        results.multiHandLandmarks.forEach((lm) => {

            drawConnectors(canvasCtx, lm, HAND_CONNECTIONS, { 
                color:'#00ff00',
                lineWidth: 5 
            });

            drawLandmarks(canvasCtx, lm, { 
                color: '#fff', 
                lineWidth: 1, 
                radius: 2 
            });

            const isUp = (t, p) => lm[t].y < lm[p].y;
            const pinch = Math.hypot(
                lm[8].x - lm[4].x,
                lm[8].y - lm[4].y
            );

            if (pinch < 0.04) detected = 'purple';

else if (isUp(8,6) && isUp(12,10) && isUp(16,14) && isUp(20,18))
    detected = 'shrine';

/* ðŸŒª NEW TORNADO GESTURE */
else if (isUp(8,6) && isUp(12,10) && isUp(16,14) && !isUp(20,18))
    detected = 'tornado';

else if (isUp(8,6) && isUp(12,10) && !isUp(16,14))
    detected = 'void';

else if (isUp(8,6) && !isUp(12,10))
    detected = 'red';
        });
    }

    /*  STABILITY LOGIC */
    if (detected === lastDetected) {
        stabilityFrames++;
    } else {
        stabilityFrames = 0;
    }

    lastDetected = detected;

   if (stabilityFrames > REQUIRED_STABILITY) {
    const now = performance.now();

    if (now - lastSwitchTime > SWITCH_COOLDOWN) {
        stableDetected = detected;
        lastSwitchTime = now;
    }
}


    updateState(stableDetected);
});
// function getTornado(i) {

//     const radius = 10 + Math.random() * 25;
//     const angle = Math.random() * Math.PI * 2;
//     const height = (Math.random() - 0.5) * 60;

//     return {
//         x: radius * Math.cos(angle),
//         y: height,
//         z: radius * Math.sin(angle),

//         r: 0.2,
//         g: 1.0,
//         b: 0.7,

//         s: 1.2
//     };
// }

function updateState(tech) {

    if(currentTech === tech) return;

    currentTech = tech;

    const nameEl = document.getElementById('technique-name');

    /* ACTIVATION SURGE */
    activationPulse = 1.35;

    /* TECHNIQUE PERSONALITY */
    if(tech === 'purple') shakeIntensity = 0.6;      // violent unstable ðŸ˜ˆ
    else if(tech === 'red') shakeIntensity = 0.35;
    else if(tech === 'shrine') shakeIntensity = 0.15; // calm deadly ðŸ˜Œ
    // else if(tech === 'tornado') p = getTornado(i);
    else shakeIntensity = 0;

    /* BLOOM TARGETS (Smooth Transition Ready) */
    if(tech === 'shrine') {
        glowColor = '#ff0000';
        nameEl.innerText = "Domain Expansion: Malevolent Shrine";
        targetBloom = 2.8;
    }
    else if(tech === 'purple') {
        glowColor = '#bb00ff';
        nameEl.innerText = "Secret Technique: Hollow Purple";
        targetBloom = 4.2;
    }
    else if(tech === 'void') {
        glowColor = '#00ffff';
        nameEl.innerText = "Domain Expansion: Infinite Void";
        targetBloom = 2.0;
    }
    else if(tech === 'red') {
        glowColor = '#ff3333';
        nameEl.innerText = "Reverse Cursed Technique: Red";
        targetBloom = 2.5;
    }
    else {
        glowColor = '#00ffff';
        nameEl.innerText = "Neutral State";
        targetBloom = 1.2;
    }

    /* PARTICLE TARGET UPDATE */
    for(let i=0; i<COUNT; i++) {

        let p;

        if(tech === 'neutral') {

            if(i < COUNT * 0.05) {
                const r = 15 + Math.random()*20;
                const t = Math.random()*6.28;
                const ph = Math.random()*3.14;

                p = {
                    x: r*Math.sin(ph)*Math.cos(t),
                    y: r*Math.sin(ph)*Math.sin(t),
                    z: r*Math.cos(ph),
                    r: 0.1,
                    g: 0.1,
                    b: 0.2,
                    s: 0.4
                };

            } else {

                p = { x:0, y:0, z:0, r:0, g:0, b:0, s:0 };
            }
        }
    else if(tech === 'red') p = getRed(i);
    else if(tech === 'void') p = getVoid(i);
    else if(tech === 'purple') p = getPurple(i);
    else if(tech === 'shrine') p = getShrine(i);
    else if(tech === 'tornado') p = getTornado(i);  

    targetPositions[i*3]     = p.x;
    targetPositions[i*3 + 1] = p.y;
    targetPositions[i*3 + 2] = p.z;

    targetColors[i*3]     = p.r;
    targetColors[i*3 + 1] = p.g;
    targetColors[i*3 + 2] = p.b;

    targetSizes[i] = p.s;
}
}

    
  

const cameraUtils = new Camera(videoElement, {
    onFrame: async () => {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;

        await hands.send({ image: videoElement });
    },
    width:640,
    height:480
});
cameraUtils.start();

/* INIT */
updateState("neutral");

/* Drag */
const videoContainer = document.getElementById("video-container");
let isDragging=false, offsetX, offsetY;

videoContainer.addEventListener("mousedown", e=>{
    isDragging=true;
    offsetX = e.clientX - videoContainer.offsetLeft;
    offsetY = e.clientY - videoContainer.offsetTop;
});

document.addEventListener("mousemove", e=>{
    if(!isDragging) return;
    videoContainer.style.left = `${e.clientX-offsetX}px`;
    videoContainer.style.top = `${e.clientY-offsetY}px`;
});

document.addEventListener("mouseup", ()=> isDragging=false);

function animate() {
    requestAnimationFrame(animate);

    activationPulse += (1 - activationPulse) * 0.12;
    particles.scale.multiplyScalar(activationPulse);


    const time = Date.now();

    /*  SMOOTH SHAKE (Less chaotic) */
    if (shakeIntensity > 0) {
        const shakeX = Math.sin(time * 0.02) * shakeIntensity * 8;
        const shakeY = Math.cos(time * 0.025) * shakeIntensity * 8;

        renderer.domElement.style.transform =
            `translate(${shakeX}px, ${shakeY}px)`;
    } else {
        renderer.domElement.style.transform = 'translate(0,0)';
    }

    const pos = particles.geometry.attributes.position.array;
    const col = particles.geometry.attributes.color.array;
    const siz = particles.geometry.attributes.size.array;

    /* PARTICLE INTERPOLATION */
    for (let i = 0; i < COUNT * 3; i++) {
        pos[i] += (targetPositions[i] - pos[i]) * 0.08;
        col[i] += (targetColors[i] - col[i]) * 0.08;
    }

    for (let i = 0; i < COUNT; i++) {
        siz[i] += (targetSizes[i] - siz[i]) * 0.08;
    }

    particles.geometry.attributes.position.needsUpdate = true;
    particles.geometry.attributes.color.needsUpdate = true;
    particles.geometry.attributes.size.needsUpdate = true;

    /* GLOBAL ENERGY BREATHING */
    const breathe = 1 + Math.sin(time * 0.0015) * 0.02;

    /* tECHNIQUE-SPECIFIC ANIMATION */
    if (currentTech === 'red') {

        particles.rotation.z -= 0.08;
        particles.scale.setScalar(breathe);

        bloomPass.strength = 2.5 + Math.sin(time * 0.01) * 0.3;

    } 
    else if (currentTech === 'purple') {

        particles.rotation.z += 0.18;
        particles.rotation.y += 0.04;

        const surge = 1 + Math.sin(time * 0.01) * 0.05;
        particles.scale.setScalar(surge);

        bloomPass.strength = 4.0 + Math.sin(time * 0.02) * 0.6;

    } 
    else if (currentTech === 'shrine') {

        /* FORCE STILLNESS */
        particles.rotation.set(0, 0, 0);
        particles.scale.setScalar(1);

        bloomPass.strength = 2.5;

    } 
    else {  // Neutral / Void

    particles.rotation.y += 0.004;
    particles.scale.setScalar(breathe);

   bloomPass.strength += (targetBloom - bloomPass.strength) * 0.08;

}

/* ðŸŒŠ NEW LAYERED ANIMATIONS */
const ripple = 1 + Math.sin(time * 0.003) * 0.01;
particles.scale.multiplyScalar(ripple);

if(currentTech !== 'neutral') {
    const aura = 1 + Math.sin(time * 0.006) * 0.015;
    particles.scale.multiplyScalar(aura);
}

particles.position.y = Math.sin(time * 0.001) * 0.3; 

/* ðŸ˜ˆ Hollow Purple â†’ Vortex Pull */
if(currentTech === 'purple') {

    const shear = Math.sin(time * 0.002) * 0.3;

    particles.rotation.x = shear;
}


/* ðŸŒŒ Infinite Void â†’ Gravitational Stretch */
if(currentTech === 'void') {

    const warp = 1 + Math.sin(time * 0.002) * 0.05;
    particles.scale.set(1, warp, 1);
}

/* ðŸ”´ Red â†’ Beam Pressure Surge */
if(currentTech === 'red') {

    particles.position.z = Math.sin(time * 0.01) * 2;
}

/* âš” Shrine â†’ Slashing Pulse */
if(currentTech === 'shrine') {

    const slash = 1 + Math.sin(time * 0.02) * 0.03;
    particles.scale.set(slash, 1, slash);
}
if(currentTech === 'void') {

    for(let i = 0; i < COUNT; i += 10) {   // performance safe ðŸ˜Œ
        const ix = i * 3;

        const x = pos[ix];
        const y = pos[ix + 1];
        const z = pos[ix + 2];

        const angle = Math.atan2(y, x) + 0.08;

        const radius = Math.sqrt(x*x + y*y);

        pos[ix]     = Math.cos(angle) * radius;
        pos[ix + 1] = Math.sin(angle) * radius;

        pos[ix + 2] = z + Math.sin(time * 0.002 + radius) * 0.05;
    }
}



composer.render();

}

animate();



/* Resize */
addEventListener("resize", ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    composer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
